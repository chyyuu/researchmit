environment:
 i_map: the inode array(map)    SIMap = symtypes.tmap(SInum, SInode)
 pipes: the pipe                SPipeMap = symtypes.tmap(SPipeId, SPipe)
 root_dir : root directory      SDirMap = symtypes.tdict(SFn, SInum)
 2 procs, proc0/proc1           SProc = symtypes.tstruct(fd_map = SFdMap, va_map = SVaMap)  //SFdMap==tdict(simsym.SInt, SFd)  SVaMap==symtypes.tdict(SVa, SVMA)  
 
  each proc has a fd_map(SFdMap) and va_map(SVaMap) 
     |
     ---->fd_map( type is SFdMap) is a array of fd,  fd_array[SInt]= SFd == {inode num, off, ispipe, pipeid}
     |     inode num(type is SInum expr sort in z3, not a Interger!),  off (file R/W offset), ... 
     |       |
     |       ----the inode num --> a index of inode array (type is SIMap), inode_array[SInum]=SInode
     |                              |   
     |                              ----> inode is a structure (SInode)
     |                                     |
     |                                     ---> data (SData， tlist(SDataByte)， abstract file data block), 
     |                                          nlink (link num), atime/mtime/ctime
     |
     --->va_map is a list of memory blocks list[va]=vma type(va)=SVa, type(vma)=SVma
           |
           ---> type(va)=SVa, which is a abstract expr sort in z3, not a Interger! 
           |
           ---> type(vma)=SVma,  anon(SBool), anondata(SDataByte) a data block, SData 是否更好？
                                 writable(SBool, inum(SInum, for mmap a file), off(SInt, off of a file),  


                                 
                                 
-----------------
Symbolic Define


                          Symbolic
                          _z3_sort(cls)     #"""Return the Z3 sort of objects represented by this class."""
                          _z3_value(self)   #"""Return the Z3 value wrapped by this object.  For mutable objects, this should be its current value."""
                          _new_lvalue(cls, init) #"""Return a new instance of Symbolic with the given initial value, which must be a Z3 value."
                          _wrap_lvalue(cls, getter, setter) #"""Create an instance of this object wrapping the Z3 value returned by getter. 
                          any(cls, name=None) #"""Return a symbolic value whose concrete value is unknown."""
                          _assumptions(cls, obj):  """Return the assumptions that should apply to a fresh created lvalue of 'obj'."""
                          init_assumptions(self): return wrap(z3.BoolVal(True))
                          __ne__(self, o): r = self == o ; return symnot(r)
                             |
                       ------------------------------------------------------------------------------------------------------
                       |                     |                |                       |                  |                  |               |            |
                      SymbolicConst        SExpr            SMapBase             SStructBase           SListBase        SDictBase        SSetBase     SBagBase
                                           z3.ExprRef        tmap                  tstruct        tstruct(tmap,SInt) tstruct(tmap,tmap) tstruct(tmap) tstruct(tmap)
                    immutable values        __str__     sort = z3.ArraySort   sort = z3.Datatype    _vals, _len       _map  _valid        _bmap         _imap
                    any(cls, name=None)    __repr__       
                    _wrap_lvalue(cls,...)  _z3_value
         参数                                         (indexType,valueType)     (**fields)        (valueType)   (keyType, valueType) (valueType)(valueType)         

 调用tstruct的参数   tlist::tstruct(_vals = tmap(SInt, valueType), _len = SInt) 
                    tdict::tstruct(_map = tmap(keyType, valueType),_valid = tmap(keyType, SBool)) 
                    tset::tstruct(_bmap = mapType)    mapType = tmap(valueType, SBool) ???
                    tbag::tstruct(_imap = mapType)    mapType = tmap(valueType, SInt) ???
                       |                     |
 -------------------------------         ----------------------------------------------------------------------------------------------------------------
                                           |                |                              |                                 |           |             |
                                         SArith           SBool                         SEnumBase                          STupleBase   SConstMapBase
                                         z3.ArithRef   __ref_type__ = z3.BoolRef         __ref_type__ = z3.DatatypeRef      <--same    __ref_type__ = z3.ArrayRef  
                                         +/-/*...     __z3_sort__ = z3.BoolSort()       z3.EnumSort                        z3.Datatype
                                         >/</!=...    __nonzero__ #how to do TRUE!!!                  type(name, (STupleBase, SymbolicConst), fields)
                                         
                                           |
                                         -----------------------------------
                                           |
                                          SInt 
                                       __z3_sort__=z3.IntSort()
                                          
                                          
  SymbolicConst+SExpr                              
          |
  -------------------------------
    |     |      |        |    |
   SFn  SInum SDataByte  SVa  SPipeId
   
   
   ListBase(SdataByte)         
      |
     SData 

   
   SData = symtypes.tlist(SDataByte)
   
   SPipe = tstruct(data  = SData,
                   nread = simsym.SInt)   
   SPipeMap = symtypes.tmap(SPipeId, SPipe) 
   
   SFd = simsym.tstruct(ispipe      = simsym.SBool,
                        pipeid      = SPipeId,
                        pipewriter  = simsym.SBool,
                        inum        = SInum,
                        off         = simsym.SInt)
  SFdMap = symtypes.tdict(simsym.SInt, SFd)              
              
              
  SVMA = simsym.tstruct(anon        = simsym.SBool,
                        writable    = simsym.SBool,
                        inum        = SInum,
                        off         = simsym.SInt,
                        anondata    = SDataByte)
  SVaMap = symtypes.tdict(SVa, SVMA)  
  
  
  SProc = symtypes.tstruct(fd_map   = SFdMap,
                           va_map   = SVaMap)    
                           
  SDirMap   = symtypes.tdict(SFn, SInum)
  SInode    = simsym.tstruct(data   = SData,
                             nlink  = simsym.SInt,
                             atime  = simsym.SInt,
                             mtime  = simsym.SInt,
                            ctime   = simsym.SInt,
                            ## XXX Directories impl:
                            #isdir  = simsym.SBool,
                            #dirmap = SDirMap,
                       )
  SIMap = symtypes.tmap(SInum, SInode)            
  
  
  
对fs model初始化的了解
--------------------------------
执行 fs.py的Fs.__init__ 函数的语句时
        self.proc0 = SProc.any('Fs.proc0')
           --> Symbolic.any(Fs.proc0)
              -->Symbolic._new_lvalue(z3.Const(name, cls._z3_sort()))  
              //备注-----------------------------
                 这里看到 cls._z3_sort()的结果为DatatypeSortRef: SStruct_pfd_map_pva_map9
                 而cls为 <class 'simsym.SStruct_pfd_map_pva_map'> 
                 注意这个cls的类名来源于tstruct函数的语句
                       name = "SStruct_" + "_".join(fields.keys())    //classname=SStruct_pfd_map_pva_map
                而z3_sort的名字来源于：
                       z3name = anon_name(name)
                       sort = z3.Datatype(z3name)                     //sort=SStruct_pfd_map_pva_map9  
                这个类的type_fields的赋值在tstruct函数随后的语句中
                type_fields = {"__slots__": [], "_fields": fields, "_fieldList": fieldList,
                               "_z3name": z3name, "__z3_sort__": sort,
                               "_ctor": getattr(sort, z3name)}  
                最后调用type创建了一个新类，其基类是SStructBase：
                return type(name, (SStructBase,), type_fields)   类产生了，其类名是SStruct_pfd_map_pva_map，对应的z3 sort是SStruct_pfd_map_pva_map9 
              //---------------------------------
              _new_lvalueh函数：：Return a new instance of Symbolic with the given initial value ，此函数参数为：DatatypeRef: Fs.proc0，就是一个逻辑符号数
                  此函数执行如下语句：
                  obj = cls._wrap_lvalue(lambda: val[0], setter)
                  结果是调用了 SStructBase._wrap_lvalue(cls, getter, setter): 这里参数 
                           cls为<class 'simsym.SStruct_pfd_map_pva_map'>
                           getter <function <lambda> at 0x208cb90> , 其func_code=<code object <lambda> at 0x1b82430, file "simsym.py", line 64>
                           setter <function setter at 0x208cb18>,其func_code=<code object setter at 0x1b823b0, file "simsym.py", line 62>
                           这里 L64 即是在_new_lvalueh函数定义的lambda: val[0]，即返回val[0]
                           这里 L62 即是在_new_lvalueh函数定义的 setter,即 val[0] = nval
                           
                        -->SStructBase._wrap_lvalue(cls, getter, setter)
                           执行了obj = cls.__new__(cls) ， 执行完句后，
                           属于类simsym.SStruct_pfd_map_pva_map 的对象产生了，即<simsym.SStruct_pfd_map_pva_map object at 0x208fdd0>
                           object.__setattr__(obj, "_getter", getter)
                           object.__setattr__(obj, "_setter", setter)
                           上面3条语句不能step in ,说明是很底层的实现了，我理解含义是 obj._getter=getter,   obj._setter=setter，这样可以用来给obj设置新的属性用，
                           而这个属性保存在对象的val[0]中，注意：在上面执行到_new_lvalue时，val[0]=Fs.proc0，也就是说obj.val[0]保存了逻辑符号数
                           
                   到这里，_new_lvalueh函数中的这句话 obj = cls._wrap_lvalue(lambda: val[0], setter) 才算执行完毕。
                   
                   接下来执行 assume(cls._assumptions(obj))这句话，此语句进一步调用
                        -->Symbolic._assumptions(cls, obj)  此函数直接 return obj.init_assumptions()
                             -->Symbolic.init_assumptions(self)  此函数直接 return wrap(z3.BoolVal(True))  即 返回{SBool}True
                               此函数先调用 z3.BoolVal(val, ctx=None), 这里的val 是{bool} True 
                                   return BoolRef(Z3_mk_true(ctx.ref()), ctx)
                                        Z3_mk_true(ctx.ref())返回了一个AST表示true
                                   最后z3.BoolVal(True)的返回值是 BoolRef: True，即一个z3的逻辑值，为True
                                   wrap函数是一个封装函数，流程如下：
                                     先isinstance(ref, (bool, int, long, float))？ 这里ref的类型是BoolRef，值为True，当然就不是bool/int/long/float类型的一个具体值了。                                  再if not isinstance(ref, z3.ExprRef)？ BoolRef是z3.ExprRef的一个instance，这样不用报告异常了！
                                     下面是具体封装过程：
                                        如果是int的， return SInt._wrap(ref)
                                        如果是算术表达式Arith， return SArith._wrap(ref)
                                        最后只能是SExpr了， return SExpr._wrap(ref)
                                        如果是z3.BoolRef)(正好是！！！)，return SBool._wrap(ref)，
                                               结果调用的是MetaZ3Wrapper_wrap(cls, z3ref) cls=<class 'simsym.SBool'>, z3ref=BoolRef: True
                                               这个函数的作用 是：Construct an instance of 'cls' wrapping the given Z3 ref object.
                                                  obj = cls.__new__(cls)  执行完后 obj={SBool}True
                                                  obj._v = z3ref          执行完后， obj._v=BoolRef: True
                                                  return obj               返回！！！ obj={SBool}True
                         
                         -->调用assume({SBool}True)了                      
                                先执行assume_list.append(e)  ，执行完毕后 （注意assume_list是一个全局变量）
                                  assume_list=[And(True, ForAll(anon12, True)), True]        

                            
                            
                           


syscall logic                  
-------------------------------------------------
TLPI p72 4.3 Opening a File: open()

open (                pn=SPathname,                 //SPathname = SFn， 是一个SExpr，注意不是字符串！！！
                      creat=simsym.SBool,
                      excl=simsym.SBool,
                      trunc=simsym.SBool,
                      anyfd=simsym.SBool,
                      pid=SPid,                     //simsym.SBool 
                      internal_alloc_inum=SInum,    //一个 SExpr
                      internal_ret_fd=simsym.SInt,  //返回的fd
                      internal_time=simsym.SInt,    //创建时间？
                     )    
                     
        self.add_selfpid(pid)  // simsym.assume(pid == False OR True ，代表proc0 OR proc1
        created = False             
        anyfd = False
        _, pndirmap, pnlast = self.nameiparent(pn)   // pndirmap=root_dir(根目录)，type(root_dir)== DirMap = symtypes.tdict(SFn, SInum); pnlat==pn
        if creat:
            if not pndirmap.contains(pnlast):        // root_dir._valid[pnlast] is a SBool  如果是false，表明没有这个文件名在root_dir中
                simsym.assume(simsym.symnot(self.iused(internal_alloc_inum)))    //需要分配一个新的inode,所以生成一个表达式internal_alloc_inum is not uesed
                //表达为 !( exists(fn, (root_dir.contains(fn) && root_dir._map[fn] == inum))              ||
                           exists(fd, (proc0.fd_map.contains(fd) && proc0.fd_map._map[fd].inum == inum))    ||
                           exists(fd, (proc1.fd_map.contains(fd) && proc1.fd_map._map[fd].inum == inum)) ) 

                ## Allocating dummy variables, then assigning or asserting
                ## to/about their struct fields, and finally doing whole-struct
                ## assignment seems to be easier for Z3 than ## poking at struct
                ## members in existing large structs.
                data_empty = SData.any(simsym.anon_name('dummy_data'))
                simsym.assume(data_empty._len == 0)
                idata = SInode.any(simsym.anon_name('dummy_idata'))
                idata.data = data_empty
                idata.nlink = 1
                self.i_map[internal_alloc_inum] = idata
                pndirmap[pnlast] = internal_alloc_inum

                simsym.assume(internal_time > self.i_map[internal_alloc_inum].atime)
                simsym.assume(internal_time > self.i_map[internal_alloc_inum].mtime)
                simsym.assume(internal_time > self.i_map[internal_alloc_inum].ctime)
                self.i_map[internal_alloc_inum].atime = internal_time
                self.i_map[internal_alloc_inum].mtime = internal_time
                self.i_map[internal_alloc_inum].ctime = internal_time
                created = True                         //是否应该加一个 return('ok‘）? ,不能，因为还没有分配fd!!!
            else:
                if excl: return ('err', errno.EEXIST)  //O_EXCL 与 O_CREAT 标记一起使用时, 如果 name 指定的文件已经存在, open()调用将失败。
                                                       //这样使用是为了防止创建文件时的竞争条件。

        if not pndirmap.contains(pnlast):              //The specified file doesn’t exist, and O_CREAT was not specified, 
            return ('err', errno.ENOENT)

        inum = pndirmap[pnlast]                        //执行到这里表示这个文件存在，所以可获得inum
        if trunc:
            if not created:
                simsym.assume(internal_time > self.i_map[inum].mtime)  //为何处理时间？ for stat系统调用!!!
                simsym.assume(internal_time > self.i_map[inum].ctime)
                self.i_map[inum].mtime = internal_time
                self.i_map[inum].ctime = internal_time
            data_empty = SData.any(simsym.anon_name('dummy_data'))    //如果是已有文件，那是否要释放已有的inode data? 如果表示释放过程???
            simsym.assume(data_empty._len == 0)                       //??? del  self.i_map[inum].data，然后再赋值？
            self.i_map[inum].data = data_empty                        //现在i_map[inode_num]的data为空了，用 data_empty._len==0表示                   

        self.add_fdvar(internal_ret_fd)                               //给pseudo_sort_decls 元组列表增加了一项
        simsym.assume(internal_ret_fd >= 0)                           // 返回的fd一定是>=0的
        simsym.assume(simsym.symnot(self.getproc(pid).fd_map.contains(internal_ret_fd))) //procX的fd_map中应该没有用过这个值 即_vaild(tmap(internal_ret_fd)=false

        ## Lowest FD
        otherfd = simsym.SInt.any('fd')
        simsym.assume(simsym.symor([anyfd,          //如果anyfd为false，则表示要取最小值的那个free的fd为返回条件。 not(otherfd < internal_ret_fd)
            simsym.symnot(simsym.exists(otherfd,
                simsym.symand([otherfd >= 0,
                               otherfd < internal_ret_fd,
                               self.getproc(pid).fd_map.contains(otherfd)])))]))

        fd_data = SFd.any(simsym.anon_name('dummy_fd_data'))
        fd_data.inum = inum
        fd_data.off = 0
        fd_data.ispipe = False
        self.getproc(pid).fd_map[internal_ret_fd] = fd_data      //这里open一个文件的操作做完了， fd_map[internal_ret_fd]=fd_data, 且
                                                                 //fd_data.inum=inode_num,且 pndirmap[path name]=inode_num , 且 i_map[inode_inum] = a inode data 

        return ('ok', internal_ret_fd)                     

执行完后
idata = SInode.any(simsym.anon_name('dummy_idata'))
idata的各个field是
FuncDeclRef: SStruct_atime_nlink_data_ctime_mtime9
_fieldlist={list}[('atime', <class 'simsym.SInt'>), ('nlink', <class 'simsym.SInt'>), ('data', <class 'symtypes.SList_SDataByte'>), ('ctime', <class 'simsym.SInt'>), ('mtime', <class 'simsym.SInt'>)]
_fields={dict}{'atime': <class 'simsym.SInt'>, 'nlink': <class 'simsym.SInt'>, 'data': <class 'symtypes.SList_SDataByte'>, 'ctime': <class 'simsym.SInt'>, 'mtime': <class 'simsym.SInt'>}
_z3name={str}'SStruct_atime_nlink_data_ctime_mtime9'


---------------------------------------------------------
TLPI p80 4.6 Closing a File: close()

    @model.methodwrap(fd=simsym.SInt, pid=SPid)                
    def close(self, fd, pid):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        if not self.getproc(pid).fd_map.contains(fd):              //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        del self.getproc(pid).fd_map[fd]                           //删除这一项 ???是否考虑unlink的情况？如果i_map[inum].nlink==0 需要清除
        return ('ok',)
                             
---------------------------------------------------------
    @model.methodwrap(src=SPathname, dst=SPathname,             //SPathname = SFn， 是一个SExpr，注意不是字符串！！！
                      internal_time=simsym.SInt)
    def rename(self, src, dst, internal_time):                  
        srcdiri, srcdirmap, srclast = self.nameiparent(src)     //return 0, root_dir, src
        dstdiri, dstdirmap, dstlast = self.nameiparent(dst)     //return 0, root_dir, dst
        if not srcdirmap.contains(srclast):                     // src 不存在，返回错误ENOENT
            return ('err', errno.ENOENT)
        if srcdiri == dstdiri and srclast == dstlast:           // 如果src==dst  啥也不做, return ok.  但srclast == dstlast这个条件是否多余？
            return ('ok',)
        if dstdirmap.contains(dstlast):                         // 如果dst存在，则dstinum = root_dir[dst]
            dstinum = dstdirmap[dstlast]
        else:
            dstinum = None                                      // 如果dst以前不存在，这没有对应的dstinum, 所以dstinum=None
        dstdirmap[dstlast] = srcdirmap[srclast]                // root_dir[dst]= root_dir[src] 这样dst文件名指向了src文件名对应的那个inode num， 
        del srcdirmap[srclast]                                 // 删除 root_dir[src] 这样root_dir中的dict结构就少了一项
        if dstinum is not None:                                          //如果dstinum不为空，这需要把其nlink--，因为它已经指向另外一个文件的inode了
            self.i_map[dstinum].nlink = self.i_map[dstinum].nlink - 1    //如果为nlink==0,是否需要删除这个inode_num对应的data???   
            simsym.assume(internal_time > self.i_map[dstinum].ctime)
            self.i_map[dstinum].ctime = internal_time
        return ('ok',)
        
----------------------------------------------------------
TLPI p391 chapt:18.3 Creating and Removing (Hard) Links: link() and unlink()
In addition to maintaining a link count for each i-node, the kernel also counts open
file descriptions for the file (see Figure 5-2, on page 95). If the last link to a file is
removed and any processes hold open descriptors referring to the file, the file
won’t actually be deleted until all of the descriptors are closed.
NOTICE: p95 figure 5.2 说明了3种情况: dup, fork, open/open

    @model.methodwrap(pn=SPathname, internal_time=simsym.SInt)
    def unlink(self, pn, internal_time):
        _, dirmap, pnlast = self.nameiparent(pn)                // return root_dir, pn
        if not dirmap.contains(pnlast):                         // root_dir中pn文件不存在，返回错误                 
            return ('err', errno.ENOENT)                        
        inum = dirmap[pnlast]                                   //得到inum
        del dirmap[pnlast]                                      //把这个文件在root_dir中的项删除
        self.i_map[inum].nlink = self.i_map[inum].nlink - 1     //nlink数减一，如果为nlink==0,是否需要删除这个inode_num对应的data??? 
        simsym.assume(internal_time > self.i_map[inum].ctime)
        self.i_map[inum].ctime = internal_time                  //没有考虑有进程打开了这个文件，(这有一个系统级别的表记录此事，Open file table， oft), 如果这样，需要判断，
                                                                //如果oft[]没有这个文件了，表示没有进程打开此文件，就可以删除此inode了，即del self.i_map[inum]???
        return ('ok',)

------------------------------------------------------------
    @model.methodwrap(oldpn=SPathname, newpn=SPathname, internal_time=simsym.SInt)
    def link(self, oldpn, newpn, internal_time):
        olddiri, olddirmap, oldlast = self.nameiparent(oldpn)   // return root_dir, old
        newdiri, newdirmap, newlast = self.nameiparent(newpn)   // return root_dir, new
        if not olddirmap.contains(oldlast):                     // root_dir中old文件不存在，返回错误
            return ('err', errno.ENOENT)
        if newdirmap.contains(newlast):                         // root_dir中new文件存在，返回错误
            return ('err', errno.EEXIST)
        inum = olddirmap[oldlast]
        newdirmap[newlast] = inum                               // root_dir有对应关系了
        self.i_map[inum].nlink = self.i_map[inum].nlink + 1     // nlink加一
        simsym.assume(internal_time > self.i_map[inum].ctime)
        self.i_map[inum].ctime = internal_time
        return ('ok',) 
------------------------------------------------------------
TLPI p79

    @model.methodwrap(fd=simsym.SInt, pid=SPid, internal_time=simsym.SInt)
    def read(self, fd, pid, internal_time):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        if not self.getproc(pid).fd_map.contains(fd):           //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        if self.getproc(pid).fd_map[fd].ispipe:                 //cont...
            if self.getproc(pid).fd_map[fd].pipewriter:
                return ('err', errno.EBADF)
            pipe = self.pipes[self.getproc(pid).fd_map[fd].pipeid]
            if pipe.data.len() == pipe.nread:
                ## TODO: return EOF if no more writers; otherwise block
                return ('err', 0)
            simsym.assume(pipe.nread < pipe.data.len())
            simsym.assume(pipe.nread >= 0)
            d = pipe.data[pipe.nread]
            pipe.nread = pipe.nread + 1
            return ('data', d)
        off = self.getproc(pid).fd_map[fd].off              //从fd_map中获得off, 这样知道从哪里读了
        r = self.iread(self.getproc(pid).fd_map[fd].inum, off, internal_time)  //实际的inode读， 
        if r[0] == 'data':                                 //表示inode读成功！ r[1]=i_map[inum].data[off],没有用处。
            self.getproc(pid).fd_map[fd].off = off + 1     //逻辑上表示向前走了一格???  如果是这样，如何表示不同进程读写不同的文件部分？这要取[off, off+len]相互不等???
        return r

----------------------------------------------------------------
TLPI p80
        
    @model.methodwrap(fd=simsym.SInt, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
    def write(self, fd, databyte, pid, internal_time):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        if not self.getproc(pid).fd_map.contains(fd):      //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        if self.getproc(pid).fd_map[fd].ispipe:            //cont...
            if not self.getproc(pid).fd_map[fd].pipewriter:
                return ('err', errno.EBADF)
            pipe = self.pipes[self.getproc(pid).fd_map[fd].pipeid]
            ## TODO: return EPIPE if no more readers
            simsym.assume(pipe.nread < pipe.data.len())
            simsym.assume(pipe.nread >= 0)
            pipe.data.append(databyte)
            return ('ok',)
        off = self.getproc(pid).fd_map[fd].off            
        self.getproc(pid).fd_map[fd].off = off + 1         //逻辑上表示向前走了一格???  是否应该write成功后做加法???  由于iwrite都返回ok,所以放在这好像也没啥。  
        return self.iwrite(self.getproc(pid).fd_map[fd].inum, off, databyte, internal_time)         

---------------------------------------------------------------------
TLPI p98 File I/O at a Specified Offset: pread() and pwrite()

Calling pread() is equivalent to atomically performing the following calls:
    off_t orig;
    orig = lseek(fd, 0, SEEK_CUR);
    lseek(fd, offset, SEEK_SET);
    s = read(fd, buf, len);
    lseek(fd, orig, SEEK_SET);
    /* Save current offset */
    /* Restore original file offset */
These system calls can be particularly useful in multithreaded applications. 

    @model.methodwrap(fd=simsym.SInt, off=simsym.SInt, pid=SPid, internal_time=simsym.SInt)
    def pread(self, fd, off, pid, internal_time):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        self.add_offvar(off)
        if not self.getproc(pid).fd_map.contains(fd):       //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        if self.getproc(pid).fd_map[fd].ispipe:             //cont...
            return ('err', errno.ESPIPE)
        return self.iread(self.getproc(pid).fd_map[fd].inum, off, internal_time)  off从参数中取，而不是从fd_map[fd].off中取，
 
 ---------------------------------------------------------------------
 TLPI p98 File I/O at a Specified Offset: pread() and pwrite()

    @model.methodwrap(fd=simsym.SInt, off=simsym.SInt, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
    def pwrite(self, fd, off, databyte, pid, internal_time):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        self.add_offvar(off)
        if not self.getproc(pid).fd_map.contains(fd):           //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        if self.getproc(pid).fd_map[fd].ispipe:                 //cont...
            return ('err', errno.ESPIPE)
        return self.iwrite(self.getproc(pid).fd_map[fd].inum, off, databyte, internal_time)   // always return ok 
        
--------------------------------------------------
TLPI p279 15.1 Retrieving File Information: stat()

    @model.methodwrap(pn=SPathname)
    def stat(self, pn):
        _, dirmap, pnlast = self.nameiparent(pn)     
        if not dirmap.contains(pnlast):                          //没有这个文件，报错返回
            return ('err', errno.ENOENT)
        return self.istat(dirmap[pnlast])                       //全部ok

--------------------------------------------------
TLPI p279 15.1 Retrieving File Information: stat()

    @model.methodwrap(fd=simsym.SInt, pid=SPid)
    def fstat(self, fd, pid):
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        if not self.getproc(pid).fd_map.contains(fd):          //没有执行open，所以没有fd，报错返回
            return ('err', errno.EBADF)
        if self.getproc(pid).fd_map[fd].ispipe:                //cont... 
            return ('ok', 0, 0, 0, 0, 0, 0)
        return self.istat(self.getproc(pid).fd_map[fd].inum)   //全部ok


--------------------------------------------------
TLPI p1020 : 49.2 Creating a Mapping: mmap()
Private file mapping:
Private anonymous mapping: 
Shared file mapping: 
Shared anonymous mapping:

Mappings are lost when a process performs an exec(), but are inherited by the
child of a fork(). 
创建一个vma后，在munmap中有 del self.getproc(pid).va_map[va] 操作
没有考虑page fault的情况。
没有考虑shared, private属性
没有考虑anon清零的处理。

    @model.methodwrap(anon=simsym.SBool,
                      writable=simsym.SBool,
                      fixed=simsym.SBool,
                      va=SVa,
                      fd=simsym.SInt,
                      off=simsym.SInt,
                      pid=SPid,
                      internal_freeva=SVa)
    def mmap(self, anon, writable, fixed, va, fd, off, pid, internal_freeva):
        ## TODO: MAP_SHARED/MAP_PRIVATE for files
        ##       -> how to model delayed file read?
        ## TODO: MAP_SHARED/MAP_PRIVATE for anon (with fork)
        ## TODO: zeroing anon memory
        self.add_selfpid(pid)
        self.add_fdvar(fd)
        self.add_offvar(off)
        myproc = self.getproc(pid)
        if not fixed:
            va = internal_freeva
            simsym.assume(simsym.symnot(myproc.va_map.contains(va))) //表示出va不在va_map中的逻辑
        vma = SVMA.any(simsym.anon_name('dummy_vma'))                //创建一个vma
        vma.anon = anon                                              //vma的anonymous属性
        vma.writable = writable                                      //vma的write属性
        if not anon:
            if not myproc.fd_map.contains(fd):       
                return ('err', errno.EBADF)     //如果 not anon && fd_map[fd]是空的，return EBADF
            if myproc.fd_map[fd].ispipe:   
                return ('err', errno.EACCES)    //cont....
            vma.off = off                       // 如果不是 anon, 表示是file，且fd_map[fd]有效，在此情况下
            vma.inum = myproc.fd_map[fd].inum   // 设置vma.off 和 vma.inum
                                                // 
        myproc.va_map[va] = vma                 // 执行到这里，可能是file,也可能是anon mem, 在任一情况下
        return ('ok', va)                       // 设置va_map[va] = vma


-----------------------------------------------
TLPI p1023 49.3 Unmapping a Mapped Region: munmap()


    @model.methodwrap(va=SVa, pid=SPid)
    def munmap(self, va, pid):
        self.add_selfpid(pid)
        del self.getproc(pid).va_map[va]    //直接删除va_map[va]
        return ('ok',)        


--------------------------------------------------------------
TLPI P1045 50.1 Changing Memory Protection: mprotect()


    @model.methodwrap(va=SVa, writable=simsym.SBool, pid=SPid)
    def mprotect(self, va, writable, pid):
        self.add_selfpid(pid)
        myproc = self.getproc(pid)
        if not myproc.va_map.contains(va): 
            return ('err', errno.ENOMEM)       //如果va_map[fd]是空的，return ENOMEM
        myproc.va_map[va].writable = writable  //设置va_map[va].writable = writable
        return ('ok',)


---------------------------------------------------------------
    @model.methodwrap(va=SVa, pid=SPid, internal_time=simsym.SInt)
    def mem_read(self, va, pid, internal_time):
        self.add_selfpid(pid)
        myproc = self.getproc(pid)
        if not myproc.va_map.contains(va):
            return ('signal', signal.SIGSEGV)   //如果va_map[fd]是空的，return SIGSEGV
        if myproc.va_map[va].anon:
            return ('data', myproc.va_map[va].anondata)//is anon mem, so read a databyte from va_map[va].anondata
        ## TODO: memory-mapped reads don't bump atime?
        internal_time = None
        return self.iread(myproc.va_map[va].inum, myproc.va_map[va].off, internal_time) //file inode read

    @model.methodwrap(va=SVa, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
    def mem_write(self, va, databyte, pid, internal_time):
        self.add_selfpid(pid)
        myproc = self.getproc(pid)
        if not myproc.va_map.contains(va):
            return ('signal', signal.SIGSEGV)
        if not myproc.va_map[va].writable:
            return ('signal', signal.SIGSEGV)
        if myproc.va_map[va].anon:
            myproc.va_map[va].anondata = databyte     // is anon mem, so write a databyte in va_map[va].anondata
            return ('ok',)
        ## TODO: memory-mapped writes don't bump mtime/ctime?
        internal_time = None
        return self.iwrite(myproc.va_map[va].inum, myproc.va_map[va].off,
                           databyte, internal_time)   // file inode write

---------------------------------------------

inode级别的操作
---------------------------------------------
TLPI p280 15.1 Retrieving File Information: stat() 下面是还没有考虑的属性
dev_t       st_dev; /* IDs of device on which file resides */
ino_t       st_ino;
mode_t      st_mode;
uid_t       st_uid;
gid_t       st_gid;
dev_t       st_rdev; /* IDs for device special files */
off_t       st_size; /* Total file size (bytes) */
blksize_t   st_blksize; /* Optimal block size for I/O (bytes) */
blkcnt_t    st_blocks;  /* Number of (512B) blocks allocated */


    def istat(self, inum):                                       //返回stat需要的各方面内容
        len = self.i_map[inum].data._len
        nlink = self.i_map[inum].nlink
        atime = self.i_map[inum].atime
        mtime = self.i_map[inum].mtime
        ctime = self.i_map[inum].ctime
        return ('ok', inum, len, nlink, atime, mtime, ctime)
                 
--------------------------------------------------------------------
inode 级别的read，每次读一个disk block (or unit)？

    def iread(self, inum, off, time):
        simsym.assume(off >= 0)
        if off >= self.i_map[inum].data._len:              //读到文件结尾了
            return ('eof',)
        if time is not None:                               
            simsym.assume(time > self.i_map[inum].atime) 
            self.i_map[inum].atime = time
        return ('data', self.i_map[inum].data[off])       //正常返回,  self.i_map[inum].data[off]的值
        
--------------------------------------------------------------------
inode 级别的write

    def iwrite(self, inum, off, databyte, time):                  
                                                                  //这里假定了i_map[inum]一定有东西。sure???
        simsym.assume(off >= 0)                                   //???有做减法的地方吗？是否有必要？
        ## Avoid overly-long files.  fs-test.py caps file size at 16 units.
        simsym.assume(off < 10)                                   //确保文件write的off不超过10                      
        ## XXX Handle sparse files?
        simsym.assume(off <= self.i_map[inum].data._len)         // 加上前面的条件，这样好像对sparse file不合理???

        if off == self.i_map[inum].data._len:                    // 正好在文件尾部，这样可以增加内容
            self.i_map[inum].data.append(databyte)
        else:
            self.i_map[inum].data[off] = databyte                // 在文件中间某处写一个unit的databyte
        if time is not None:
            simsym.assume(time > self.i_map[inum].mtime)
            simsym.assume(time > self.i_map[inum].ctime)
            self.i_map[inum].mtime = time
            self.i_map[inum].ctime = time
        return ('ok',)
        
--------------------------------------------------
对内部变量的描述和处理
在IsomorphicMatch的process_model方法中
    def process_model(self, model):
        for decl in model:
            ## Do not bother including "internal" variables in the wrapped model;
            ## otherwise Z3 can iterate over different assignments to these
            ## variables, while we care only about assignments to "external"
            ## variables.
            if '!' in str(decl) or 'internal_' in str(decl) or 'dummy_' in str(decl):
                continue
            self.process_decl_assignment(decl, model[decl], model)
意味着对!, internal_, dummy_ 的变量不做处理          


包含 internal_  的变量名
-----------------
spec.py

    # Internal variables help deal with situations where, for the same
    # assignment of initial state + external inputs, two operations both
    # can commute and can diverge (depending on internal choice, like the
    # inode number for file creation).
    commute = simsym.symor(conds[()])
    cannot_commute = simsym.symnot(simsym.exists(simsym.internals(), commute))

simsym.py
#
# Helpers for tracking "internal" variables
#

internal_vars = {None: SInt.any('__dummy')}                                                            

model.py
l13: important
                if arg.startswith('internal_'):
                    simsym.add_internal(args[arg])


simtype.py
l94:           add_internal(v)


chy@chyhome-PC:~/mit/sck/spec4$ grep -Hn internal *.py
fs.py:175:                      internal_alloc_inum=SInum,
fs.py:176:                      internal_ret_fd=simsym.SInt,
fs.py:177:                      internal_time=simsym.SInt,
fs.py:180:             internal_alloc_inum, internal_ret_fd, internal_time):
fs.py:187:                simsym.assume(simsym.symnot(self.iused(internal_alloc_inum)))
fs.py:198:                self.i_map[internal_alloc_inum] = idata
fs.py:199:                pndirmap[pnlast] = internal_alloc_inum
fs.py:201:                simsym.assume(internal_time > self.i_map[internal_alloc_inum].atime)
fs.py:202:                simsym.assume(internal_time > self.i_map[internal_alloc_inum].mtime)
fs.py:203:                simsym.assume(internal_time > self.i_map[internal_alloc_inum].ctime)
fs.py:204:                self.i_map[internal_alloc_inum].atime = internal_time
fs.py:205:                self.i_map[internal_alloc_inum].mtime = internal_time
fs.py:206:                self.i_map[internal_alloc_inum].ctime = internal_time
fs.py:216:                simsym.assume(internal_time > self.i_map[inum].mtime)
fs.py:217:                simsym.assume(internal_time > self.i_map[inum].ctime)
fs.py:218:                self.i_map[inum].mtime = internal_time
fs.py:219:                self.i_map[inum].ctime = internal_time
fs.py:224:        self.add_fdvar(internal_ret_fd)
fs.py:225:        simsym.assume(internal_ret_fd >= 0)
fs.py:226:        simsym.assume(simsym.symnot(self.getproc(pid).fd_map.contains(internal_ret_fd)))
fs.py:233:                               otherfd < internal_ret_fd,
fs.py:240:        self.getproc(pid).fd_map[internal_ret_fd] = fd_data
fs.py:242:        return ('ok', internal_ret_fd)
fs.py:245:                      internal_pipeid=SPipeId,
fs.py:246:                      internal_fd_r=simsym.SInt,
fs.py:247:                      internal_fd_w=simsym.SInt,
fs.py:249:    def pipe(self, pid, internal_pipeid, internal_fd_r, internal_fd_w):
fs.py:257:                               self.proc0.fd_map._map[xfd].pipeid == internal_pipeid])),
fs.py:261:                               self.proc1.fd_map._map[xfd].pipeid == internal_pipeid]))])))
fs.py:266:        self.pipes[internal_pipeid] = empty_pipe
fs.py:269:        self.add_fdvar(internal_fd_r)
fs.py:270:        simsym.assume(internal_fd_r >= 0)
fs.py:271:        simsym.assume(simsym.symnot(self.getproc(pid).fd_map.contains(internal_fd_r)))
fs.py:274:                               xfd < internal_fd_r,
fs.py:278:        fd_r_data.pipeid = internal_pipeid
fs.py:280:        self.getproc(pid).fd_map[internal_fd_r] = fd_r_data
fs.py:283:        self.add_fdvar(internal_fd_w)
fs.py:284:        simsym.assume(internal_fd_w >= 0)
fs.py:285:        simsym.assume(simsym.symnot(self.getproc(pid).fd_map.contains(internal_fd_w)))
fs.py:288:                               xfd < internal_fd_w,
fs.py:292:        fd_w_data.pipeid = internal_pipeid
fs.py:294:        self.getproc(pid).fd_map[internal_fd_w] = fd_w_data
fs.py:296:        return ('ok', internal_fd_r, internal_fd_w)
fs.py:299:                      internal_time=simsym.SInt)
fs.py:300:    def rename(self, src, dst, internal_time):
fs.py:315:            simsym.assume(internal_time > self.i_map[dstinum].ctime)
fs.py:316:            self.i_map[dstinum].ctime = internal_time
fs.py:319:    @model.methodwrap(pn=SPathname, internal_time=simsym.SInt)
fs.py:320:    def unlink(self, pn, internal_time):
fs.py:327:        simsym.assume(internal_time > self.i_map[inum].ctime)
fs.py:328:        self.i_map[inum].ctime = internal_time
fs.py:331:    @model.methodwrap(oldpn=SPathname, newpn=SPathname, internal_time=simsym.SInt)
fs.py:332:    def link(self, oldpn, newpn, internal_time):
fs.py:342:        simsym.assume(internal_time > self.i_map[inum].ctime)
fs.py:343:        self.i_map[inum].ctime = internal_time
fs.py:355:    @model.methodwrap(fd=simsym.SInt, pid=SPid, internal_time=simsym.SInt)
fs.py:356:    def read(self, fd, pid, internal_time):
fs.py:374:        r = self.iread(self.getproc(pid).fd_map[fd].inum, off, internal_time)
fs.py:379:    @model.methodwrap(fd=simsym.SInt, off=simsym.SInt, pid=SPid, internal_time=simsym.SInt)
fs.py:380:    def pread(self, fd, off, pid, internal_time):
fs.py:388:        return self.iread(self.getproc(pid).fd_map[fd].inum, off, internal_time)
fs.py:408:    @model.methodwrap(fd=simsym.SInt, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
fs.py:409:    def write(self, fd, databyte, pid, internal_time):
fs.py:425:        return self.iwrite(self.getproc(pid).fd_map[fd].inum, off, databyte, internal_time)
fs.py:427:    @model.methodwrap(fd=simsym.SInt, off=simsym.SInt, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
fs.py:428:    def pwrite(self, fd, off, databyte, pid, internal_time):
fs.py:436:        return self.iwrite(self.getproc(pid).fd_map[fd].inum, off, databyte, internal_time)
fs.py:479:                      internal_freeva=SVa)
fs.py:480:    def mmap(self, anon, writable, fixed, va, fd, off, pid, internal_freeva):
fs.py:490:            va = internal_freeva
fs.py:523:    @model.methodwrap(va=SVa, pid=SPid, internal_time=simsym.SInt)
fs.py:524:    def mem_read(self, va, pid, internal_time):
fs.py:532:        internal_time = None
fs.py:533:        return self.iread(myproc.va_map[va].inum, myproc.va_map[va].off, internal_time)
fs.py:535:    @model.methodwrap(va=SVa, databyte=SDataByte, pid=SPid, internal_time=simsym.SInt)
fs.py:536:    def mem_write(self, va, databyte, pid, internal_time):
fs.py:547:        internal_time = None
fs.py:549:                           databyte, internal_time)
model.py:9:                if arg.startswith('internal_'):
model.py:12:                if arg.startswith('internal_'):
model.py:13:                    simsym.add_internal(args[arg])
simsym.py:856:# Helpers for tracking "internal" variables
simsym.py:859:internal_vars = {None: SInt.any('__dummy')}
simsym.py:861:def add_internal(v):
simsym.py:862:    internal_vars[str(v)] = v
simsym.py:864:def internals():
simsym.py:865:    return [v for _, v in internal_vars.iteritems()]
spec.py:152:            ## Do not bother including "internal" variables in the wrapped model;
spec.py:156:            if '!' in str(decl) or 'internal_' in str(decl) or 'dummy_' in str(decl):
spec.py:397:    # can commute and can diverge (depending on internal choice, like the
spec.py:400:    cannot_commute = simsym.symnot(simsym.exists(simsym.internals(), commute))
symtypes.py:94:        add_internal(v)



------------------------
包含 dummy_ 的变量名
------------------------



chy@chyhome-PC:~/mit/sck/spec4$ grep -Hn dummy *.py
fs.py:189:                ## Allocating dummy variables, then assigning or asserting
fs.py:193:                data_empty = SData.any(simsym.anon_name('dummy_data'))
fs.py:195:                idata = SInode.any(simsym.anon_name('dummy_idata'))
fs.py:220:            data_empty = SData.any(simsym.anon_name('dummy_data'))
fs.py:236:        fd_data = SFd.any(simsym.anon_name('dummy_fd_data'))
fs.py:263:        empty_pipe = SPipe.any(simsym.anon_name('dummy_pipe'))
fs.py:276:        fd_r_data = SFd.any(simsym.anon_name('dummy_fd_data'))
fs.py:290:        fd_w_data = SFd.any(simsym.anon_name('dummy_fd_data'))
fs.py:492:        vma = SVMA.any(simsym.anon_name('dummy_vma'))
simsym.py:859:internal_vars = {None: SInt.any('__dummy')}
spec.py:156:            if '!' in str(decl) or 'internal_' in str(decl) or 'dummy_' in str(decl):

